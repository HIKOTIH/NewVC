package Lesson1Alishev;

public class Arrays {
    public static void main(String[] args) {
        //todo
        // зафрахтована ділянка оператви якщо примітив передати кудись., він передається як є.
        int number = 10;                            //примитивный тип данных коробочка с данными
        //todo
        // також примітив., але іншого типу., спеціально під символи з всіма властивостями примітивів.
        char character = 'а';                       //то же коробка с чем то внутри

        //todo
        // тут немного не так.
        // и это важно, бо оно именно так работает:
        // мы Объявляем то, что у нас в алгоритме появляется новая логическая переменная s.
        // так как джава "строго типизированный язык"
        // Назначаем её Instance типом String (который готовый джавовский класс).


        //todo
        // в єтот момент мі еще не дошли до содержания самого объета(переменной)
        // но сам объект в джаве уже создан, уже отделена даже начальная память под этот объект
        // (хоть и пустая., но соседние "потребители" уже не имеют к ней доступа и она значится как занятая,
        // посмотри s2 , там "внутри" ничего нет но использовать переменную мы уже можем, она объявлена.

        String s2 = null;
        //todo
        // вот это называется ссылочный тип. ссылка на этот объект эта вот эта логическая переменная.
        // одна из самых распространенных ошибок джавы NullPointerException возникает когда ты пытаешся использовать функционал из ссылки.,
        // но в памяти еще ничего нет.

        //todo и уже после создания самого объекта и получив на него ссылку мы записываем в него значение.

        String s = "stroka";                        // клас стринг а справа обьект

        //todo
        // объявляется новая переменная типа Стринг и все тожесамое. но, тут есть нюанс. Класс Стринг это специальный класс,
        // у него внутри есть конструктор по умолчанию, и он вызывается автоматически.
        // Поэтому в таких классах как Integer, String, BigDecimal и тд. при объявлении новой переменной писать new ненадо
        String s1 = new String("stroka1");  // то же ссылочный тип данных на коробку с данными
        System.out.println(s + s1 + s2);

        //todo
        // массив это и не переменная и не объект в какомто роде. это жесткая СТРУКТУРА данных.
        // жесткая в том смысле что когда ты создаеш массив ты должен и четко указать тип данных и размер.
        // но логика создания такаяже как и для других ссылочных типов
        // объявляется логическая переменная numbersi которая является инстансом структуры данных массив.
        // после этого ты используеш конструктор инстанса в котором указываеш что
        // тип данных использующийся в ячейке структуры int и будет состоять из 5 одномерных ячеек

        int[] numbersi = new int[5];               // numbersi ссылается на [масив]

        //todo
        // так как примитивы не могут быть нулом., они инициализируются с значением по умолчанию

        for (int i = 0; i < numbersi.length; i++) {          //вывод строки
            System.out.println("ячейка " + i + " из int[] numbersi = " +  numbersi[i] + " ");
        }

        //todo
        // тогда как объеты без значений объявить можно., ссылки создадутся но в них ничего не будет
        Integer[] numbersiNotPrimitive = new Integer[5];               // numbersi ссылается на [масив]
        for (int i = 0; i < numbersiNotPrimitive.length; i++) {          //вывод строки
            System.out.println("ячейка " + i + "  Integer[] numbersiNotPrimitive = " +  numbersiNotPrimitive[i] + " ");
        }
        System.out.println(numbersi[3]);            // 0 1 2 3 4 все пока равны 0
        for (int i = 0; i < numbersi.length; i++) {
            //todo
            // массив уже инициализирован выше , тут ты поочереди назначаеш новое значение для каждой ячейки
            numbersi[i] = i * 10;                   // инициализация масива
        }
        for (int i = numbersi.length - 1; i >= 0; i--) { // обратный вывод строки
            System.out.print(numbersi[i] + " ");
        }
        for (int i = 0; i < numbersi.length; i++) {          //вывод строки
            System.out.print(numbersi[i] + " ");
        }
        System.out.println();

        //todo
        // !!!! основное отличие примитивов от ссылочных

        int primitiv = 1;
        IntVrapper notPrimitive = new IntVrapper(1);

        Service service = new Service();
        // во всех случаях мы ОТСЮДА берем берем 2 переменных , примитивную и не примитивную и передаем их в метод который их емняет
        // и одно будет изменятся а другое нет
        service.printData(primitiv, notPrimitive);
        service.changeValue(primitiv, notPrimitive);
        service.printData(primitiv, notPrimitive);
        service.changeValue(primitiv, notPrimitive);
        service.printData(primitiv, notPrimitive);
        service.changeValue(primitiv, notPrimitive);
        service.printData(primitiv, notPrimitive);





        // вот подумаешь над этими ифами, странет чуть прозрачней.
        // в рабочем коде вот єто "автоприведение к типу" строго запрещено
        // но оно наглдядно показівает в чем суть
        // мы объявляем самый верхний джавовский класс обжект а джава сама его приводит к удобному для нее фармату
        // а вот этим instanceof можно проверить к какому типу принадлежит объект когда он уже загружен в память

        Object i1 = 1;

        if (i1 instanceof String) {
            System.out.println(i1 + " стринг");
        }

        if (i1 instanceof Integer) {
            System.out.println(i1+ " инт");
        }

        Object s3  = "someString";

        if (s3 instanceof String) {
            System.out.println(s3 +" стринг");
        }

        if (s3 instanceof Integer) {
            System.out.println(s3 + " инт");
        }
    }


}
